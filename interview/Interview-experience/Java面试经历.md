# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")


## Java面试经历

### 案例一

一面
- 自我介绍，介绍实习，聊了一会
- redis的热榜排行如何处理的
- redis如何做持久化的（我就说RDB和AOF方式，我说你做到会用，没有深入啊，我说我屁大点项目，还得用持久化？）
- MySQL的一些问题
- RabbitMQ和Kafka的区别（我说我仅仅是做到会用，有些东西没有深入了解，她说你项目里写到Kafka和RabbitMQ了的，没考虑到他们之间的区别么，是我没考虑）
- 简历上的项目问题
- 网络中哪些协议，关于网络的知识
- http 500状态码
- 如何使用 Wireshark 抓自己写的服务的数据包
- 然后问 set 怎么实现？答：拉链法，拉链法实现个 map
- 之后问给实现的 map 加上 lru 怎么加，随便答了答


二面
- tcp 拥塞控制
- 垃圾回收过程
- docker 原理
- 问了不了解分布式协议，答：不了解
- 问看没看过 tcp 源码，答：只看过协议首部
- 递归和非递归前序遍历二叉树，几分钟写好了 
- 然后给了个力扣简单题叫说思路：二叉树的最大直径


### 三面：60mins，0418



### 其他问题补充：
HTTPS的加密方式
CA证书是什么，上面有啥内容，用户怎么验证（有点忘了，麻）
DDOS攻击是怎么样的，服务器端第三次握手会持续到什么时候
抓取过HTTP报文吧，怎么抓取HTTPS明文（我：????）
然后开始算法题
第一个统计小岛个数 DFS 我也告诉他我做过了 很快敲出来了
第二个 能看见楼的数量，高的楼会挡住矮的。比如[5,3,8,3,2,5]就是[3,3,5,4,4,4].8可以看到5,3,8,3,5, 2被挡住了。我隐约感觉是单调栈，但是没有思路，还是没做出来。
面试官说换个设计题吧我说好。设计分享码，要求长度固定，唯一，由字母和数字组成，每次差别很大。
我说每次随机生成一位，他说怎么保证唯一，我想了想说哈希表，他说那分享码越来越多怎么办。想了半天，后来他提到场景是抖音分享视频的时候的分享链接，不知道咋我才想出来用哈希函数，就是后台1,2,3这样编号，然后用哈希函数映射成一段数字和字母的组合应该可以保证唯一。总之还是想了半天才描述出来，不知道这个思路行不行。
最后是个智力题，用1小时的绳子烧出来1小时15分钟


### 问题答疑
TCP拥塞控制原理
TCP的一个关键部分就是其拥塞控制机制。TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显示的网络拥塞反馈。
TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。那么是如何限制的呢？主要通过拥塞窗口（cwnd）。运行在发送方的TCP拥塞控制机制对拥塞窗口进行跟踪，这个拥塞窗口对一个TCP发送方能向网络中发送流量的速率进行了限制。

TIME_WAIT是TCP连接断开时必定会出现的状态

粘包、拆包发生原因
发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，
1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
等等。

粘包、拆包解决办法
通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：

1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
等等。



https = 非对称加密➕数字摘要➕数字签名➕对称加密

ca证书是为了防止中间人攻击由可信第三方使用私钥对服务器公钥数字签名颁发

用户接收到服务端传来的ca证书后，会根据本地已经存在的ca机构公钥解密得到服务器公钥，还会检查证书所颁发的域名与当前域名是否一致，是否在证书有效期以内

ddos分布式拒绝服务攻击，利用分布式的大量主机同时请求服务试图耗尽服务器资源导致服务无法为正常用户提供。分为直接型ddos和反射型ddos

服务器第三次握手？不是很清楚这个问题的含义，面试时候遇到这种问题可以和面试官好好沟通下先问清楚题意

分享链接其实就是短链接生成问题，八股常问的系统设计题。原则就是尽可能短，定长，全局唯一，重定向和一对多。可以先计算url空间大小据此估计设计短链接为多长，使用数字大小写字母来组成链接，一般对于一个app来说，链接长度在5-6位即可，对于整个网络空间7位也足够了。全局唯一其实就是分布式id生成问题，即如何生成尽可能短，按照时间粗略有序且全局唯一的id，再根据id生成链接。重定向一般使用302或307重定向，不使用301主要是因为，301浏览器会对原始url缓存，302和307不会缓存，缓存之后用户访问短链接浏览器直接跳转，服务无法再去收集用户的访问信息。一对多指的是在不同时间生成的同一个视频url短链接应该不一样。


补充一下，面试官肯定还会追问分布式id生成怎么搞，比较常见的有三种方式：
- uuid
- n 台mysql服务器自增id
- snowflakeid算法

可以简单说说怎么实现这三种，对比下优缺点再根据场景选择一个最适合的告诉面试官

uuid

用来生成一串无序唯一的32位长度数据。
涉及到以太网卡地址、纳秒级时间、芯片ID等。
底层是一组32位的十六进制数字，理论上总数为1632 = 2128 ≈ 3.4×10123。
就是说每纳秒都能产生上百万个UUID，能用100亿年。
uuid理论上不会重复，random既然是随机当然可能会重复。

snowflakeid算法

雪花算法简单描述：
最高位是符号位，始终为0，二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0
41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。
10位的机器标识，10位的长度最多支持部署1024个节点, 一般是5位IDC+5位machine编号，唯一确定一台机器
12位的计数序列号，序列号即一系列的自增id（多线程建议使用atomic），可以支持同一节点同一毫秒生成多个ID序号，若同一毫秒把序列号用完了，则“等待至下一毫秒”, 12位的计数序列号支持每个节点每毫秒产生4096个ID序号。

生成的ID特点:
1、twitter的SnowFlake生成ID能够按照时间有序生成
2、SnowFlake算法生成id的结果是一个64bit大小的整数
3、分布式系统内不会产生重复id（用有datacenterId和workerId来做区分）

