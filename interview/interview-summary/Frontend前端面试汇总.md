# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")

## interview

## 目录
- [vue](#vue)
- [javascript](#javascript)
- [JVM](#JVM)
- [设计模式](#设计模式)
- [数据结构](#数据结构)
- [网络结构](#网络结构)
- [数据库](#数据库)
- [高并发与多线程](#高并发与多线程)
- [分布式与高可用](#分布式与高可用)
- [消息系统](#消息系统)
- [缓存Redis](#缓存Redis)
- [ElasticSearch搜索引擎](#ElasticSearch搜索引擎)
- [系统设计和场景](#系统设计和场景)
- [算法](#算法)

## vue

### 基础
- js中0.1+02在什么情况下回等于0.2999999：浮点数计算精度问题，浮点数在计算机中是以二进制表示的，而二进制无法精确表示某些十进制小数，导致计算结果不准确。 示例：0.1+0.2=0.30000000000000004
  - 精度丢哪儿去了？ 要把小数装入计算机，总共分几步？ 3 步。 第一步：转换成二进制 第二步：用二进制科学计算法表示 第三步：表示成 IEEE 754 形式 但第一步和第三步都有可能 丢失精度。 
  - 十进制是给人看的。但在进行运算之前，必须先转换为计算机能处理的二进制。最后，当运算完毕后，再将结果转换回十进制，继续给人看。精度就丢失于这两次转换的过程中。
  - 如何解决浮点数精度丢失：1.使用整数进行计算，最后再除以相应的倍数 2.使用toFixed()方法保留小数位数 3.使用第三方库如decimal.js等 如：保留两位小数。将小数点像右多移动 2 位（也就是放大两位小数），取整后再除以 100 即可
- <video>标签如何让浏览器自动播放：设置autoplay属性，autoplay属性是一个布尔属性，表示一旦视频就绪就开始播放。如果这个属性被设置为true，视频将自动播放。示例：<video autoplay="autoplay" controls="controls" src="movie.mp4"></video>

#### **vue生命周期及其特点**重点
vue实例从被创建到销毁的一系列过程就叫vue生命周期. 也就是从开始创建、初始化数据、编译模版、挂载DOM→渲染、更新、渲染、卸载等一系列过程。
- beforeCreate：在实例初始化之后，数据观测(data observer)和event/watcher事件配置之前被调用。
- created：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。
- beforeMount：在挂载开始之前被调用：相关的render函数首次被调用。
- mounted：el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。
- beforeUpdate：数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。
- updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。
- beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
- destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
- activated：keep-alive组件激活时调用。
- deactivated：keep-alive组件停用时调用。

#### **Vue的双向绑定原理是什么**重点
- 发布者-订阅者模式（backbone.js）
- 脏值检查（angular.js） 
- 数据劫持（vue.js）
```
Vue数据劫持的核心是Object.defineProperty，它是ES5中定义的一个API，用于在一个对象上定义一个新的属性，或者修改一个已经存在的属性。
Vue通过在对象之间设置依赖关系，使得当某个依赖变化时，所有依赖于它的数据自动更新。这种自动更新的方式是观察者模式的一种实现。
```
数据劫持+发布者订阅者模式实现
- 通过Object.defineProperty()来劫持各个属性的setter，getter，监听数据的变化
- 在数据变动时发布消息给订阅者(watcher)，订阅者触发响应的回调(update)更新视图。

Vue的双向绑定是通过Object.defineProperty()实现的。
Vue将响应式地绑定数据对象中的属性，当这些属性的值发生变化时，视图会自动更新，反之，当视图中的数据发生变化时，绑定的数据也会更新，从而保持数据的同步。
函数首先初始化视图，将obj[key]的值设置到el上。然后，使用Object.defineProperty()定义了一个属性，当属性的值被访问时，返回当前的值；当属性的值被修改时，更新视图并触发事件监听器


#### 父子组件传递数据的方法
父组件的数据要通过prop传到子组件

#### 子组件之间如何共享数据
Vuex

**vuex刷新后数据会丢失，除了把数据放本地存储外，你还知道其他什么方法吗？**
localstorage，地址栏，router参数

#### **讲一下vue3相比vue2，它在diff算法上做了哪些优化**重点
Vue 3的Diff算法相比Vue 2进行了一些具体的改进，主要包括以下几个方面：
- Patch flag：Vue 3引入了Patch flag的概念，用于标记组件在更新过程中的一些特殊情况，例如组件的props发生变化或只需要强制更新等。这样可以在Diff算法中更快速地定位需要更新的组件，减少了比较的工作量，提高了更新性能。
- 静态标记和提升：Vue 3在编译阶段对模板进行静态分析，标记出那些静态的内容，即在渲染过程中不会发生变化的部分。对于这部分静态内容，Vue 3将其提升为常量，避免了每次渲染都进行比较的开销，进一步提高了渲染性能。
- Fragments优化：在Vue 2中，Fragments（片段）会引入额外的虚拟DOM层级，导致Diff算法需要进行更多的比较操作。而在Vue 3中，对Fragments进行了优化，可以直接将其内部的内容合并到父级中，减少了虚拟DOM层级，提高了Diff算法的效率。
- 动态属性的快速路径：Vue 3通过快速路径（Fast Path）优化了动态属性的处理。对于动态属性，Vue 3会使用更快速的路径进行处理，减少了比较的开销，提高了Diff算法的性能。

总的来说，Vue 3的Diff算法在细节上进行了一系列的优化，通过引入Patch flag、静态标记和提升、Fragments优化以及动态属性的快速路径等改进，进一步提升了Diff算法的效率和性能，使得Vue 3在渲染性能方面有显著的改进。

#### **vue3相比vue2有哪些提升**
- Composition API：Vue 3引入了Composition API，提供了更灵活、更可复用的组合式API，使得组件的逻辑更加清晰和易于维护。
- Teleport：Vue 3新增了Teleport组件，可以将子组件渲染到DOM树中的任意位置，提供了更灵活的组件渲染方式。
- Suspense：Vue 3引入了Suspense组件，用于处理异步组件的加载和错误处理，提供了更好的异步组件管理机制。
- Fragments：Vue 3对Fragments进行了优化，提高了Fragments的性能和效率。
- 更好的TypeScript支持：Vue 3对TypeScript的支持更加完善，提供了更好的类型推断和类型检查，使得开发更加稳定和高效。
- 更好的性能：Vue 3在Diff算法、静态标记和提升、Fragments优化等方面进行了一系列的性能优化，提高了渲染性能和效率。
- 更好的开发体验：Vue 3提供了更多的开发工具和调试工具，使得开发更加便捷和高效。

#### Vue2为什么要对数组的常用方法进行重写？

#### Vue的nextTick是怎么实现的？

#### 讲一下computed与watch的区别
- computed 是一种计算属性，‌它可以根据一个或多个属性的值进行计算得出结果。‌computed支持缓存，‌当其依赖的属性值未发生变化时，‌会直接使用缓存中的结果，‌避免了不必要的计算。‌此外，‌computed中的函数必须使用return返回结果。‌
- watch 主要用于监听数据的变化，‌当监听的数据发生变化时，‌会触发相应的操作。‌watch不支持缓存，‌每次数据变化时都会执行相应的操作。‌watch中的函数不需要使用return，‌因为它主要用于监听数据变化并执行相应的操作，‌如异步操作或高性能消耗的操作。‌

#### vue中组件通信都有哪些方
- Props：‌这是父子组件间通信的基本方式，‌父组件通过props向子组件传递数据或方法。‌
- **emit**：‌子组件通过emit**：‌子组件通过emit∗∗：‌子组件通过emit触发事件，‌父组件监听这个事件并进行相应的处理，‌实现子组件向父组件的通信。‌
- refs/refs/refs/children：‌父组件通过refs直接访问子组件的属性和方法，‌或者通过refs直接访问子组件的属性和方法，‌或者通过refs直接访问子组件的属性和方法，‌或者通过children访问子组件集合。‌
- provide/inject：‌允许一个祖先组件向其所有子孙后代注入一个依赖，‌不论组件层级有多深，‌并能在后代的组件中使用。‌
- eventBus（‌事件总线）‌：‌创建一个空的Vue实例作为事件中心，‌允许任何组件通过该中心发送和监听事件，‌实现非父子组件间的通信。‌
- Vuex：‌对于中大型单页应用，‌Vuex是一个非常好的状态管理库，‌用于在组件间管理共享的状态。‌


### 网络 
5..axios的特点有哪些
1.	axios是一个基于promise的HTTP库,支持promise的所有API
2.	它可以拦截请求和响应
3.	它可以转换请求数据和响应数据,并对响应回来的内容自动转换为json类型的数据
4.	它安全性更高,客户端支持防御XSRF

5.axiosd有哪些常用方法
一、axios.get(url[, config])   //get请求用于列表和信息查询
二、axios.delete(url[, config])  //删除
三、axios.post(url[, data[, config]])  //post请求用于信息的添加
四、axios.put(url[, data[, config]])  //更新操作

6.谈谈javascript数组排序方法sort()的使用,重点介绍参数使用及内部机制?
语法：arrayObject.sort(sortby)
参数sortby可选，规定排序顺序，必须是函数
注：如果调用该方法是没有使用参数，将按字符编码的顺序进行排序，要实现这一点，首先应把数组的元素都转换成字符串，以便进行比较。
如果想按照其他的标准进行排序，就需要两个比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对排序的数字。比较函数应该具有两个参数a和b，其返回值如下：
若a<b，则返回一个小于0的值
若a=b，则返回一个0
若a>b，则返回一个大于0的值

7.简述DIV元素和span元素的区别
div是一个块级元素，span是内嵌元素。块元素相当于内嵌元素在前后各加了一个换行。其实，块元素和行内元素也不是一成不变的，只要给块元素定义display：inline，块元素就变成了内嵌元素，同样的，给内嵌元素定义了display：block就变成了块元素了。

8.说几条XHTML规范的内容(至少3条)
1.	所有的标记都必须有一个相应的结束标记
2.	所有标签的元素和属性的名字都必须使用小写
3.	所有的xml标记都必须合理嵌套
4.	所有的属性值都必须用引号“”括起来
5.	所有的<和&特殊符号用编码表示
6.	给所有属性赋一个值

9.对web标准化(或网站重构)知道哪些相关的知识,简述几条你知道的Web标准?
网页主要有三部分组成：结构（Structrue）、表现（presentation）和行为（Behavior）。对应的网站标准也分为三方面：
1.	结构化标准语言，主要包括XHTML和XML；
2.	表现标准主要包括css
3.	行为标准主要包括对象模型（如W3C  DOM）、ECMAScript等

10.localstorage和sessionstorage是什么?区别是什么?
localstorage和sessionstorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型对象
localstorage生命周期是永久的，这意味着除非用户在浏览器提供的UI上清除localstorage信息，否则这些信息将永远存在。
sessionstorage生命周期为当前窗口或标签，一旦窗口或标签被永久关闭了，那么所有通过sessionstorage存储的数据也将被清空。
不同浏览器无法共享localstorage或sessionstorage中的信息。相同浏览器的不同页面可以共享相同的localstorage（页面属于相同的域名和端口），但是不同页面或标签间无法共享sessionstorage。这里需要注意的是，页面及标签仅指顶级窗口，如果一个标签页包含多个iframe标签他们属于同源页面，那么他们之间是可以共享sessionstorage的。

11.如何获取一个元素的属性值
element.getAttribute('属性名称')

12.举例说明一下什么是事件委托?
事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果

13.json和jsonp的区别?
json返回的是一串json格式数据；而jsonp返回的是脚本代码（包含一个函数调用）
jsonp的全名叫做json with padding，就是把json对象用符合js语法的形式包裹起来以使其他的网站可以请求到，也就是将json封装成js文件传过去。

14.本地存储和cookie(存储在用户本地终端上的数据)之间的区别是什么?
cookie数据始终在同源http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径的概念，可以限制cookie只属于某个路径下。存储大小限制不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如回话标识。数据有效期不同，cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

15.行内元素有哪些?块级元素有哪些? 空(void)元素有哪些?
行内元素：a b span img select strong    块级元素：div ul ol li dl dt h1 p 空元素： <br> <hr> <img> <link> <meta>

16.css选择符有哪些？哪些属性可以继承？优先级算法如何计算？css3有哪些新属性？
css选择符：
.	id选择器（#myid）
.	类选择器（.myclassname）
.	标签选择器（div，h1, p）
.	相邻选择器（h1 + p）
.	子选择器（ul > li）
.	后代选择器（li a）
.	通配符选择器（*）
.	属性选择器(a[rel = 'external'])
.	伪类选择器（a:hover，li：nth-child）

可继承属性：
1.	font-size
2.	font-family
3.	color
4.	text-indent
优先级算法：
1.	优先级就近原则，同权重情况下样式定义最近者为准；
2.	载入样式以最后载入的定位为准
3.	！import > id > class > tag
4.	important 比内联优先级搞，但内联比id要高


17.简述一下 src 和 href 的区别？
scr用于替换当前元素，href用于在当前文档和引用资源之间确立关系。
src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到文档内，列如js脚本，img图片，和iframe等元素。当浏览器解析到该元素时，会暂停其他资源的加载，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似将所指向资源嵌入当前标签内。
href是Hypetext Reference的缩写，指向网络资源所在的位置，建立和当前元素（锚点）或当前文档（链接）之间链接，
如果我们在文档中添加
<link href="common.css" rel="stylesheet"/>
那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。

18.浏览器的内核分别是什么？
1.Trident内核：代表作品是IE
2.Gecko内核：代表作品Firefox
3.Webkit内核：代表作品是Safari
4.prosto内核：Opera
5.Blink内核：chrome



## javascript
**EventLoop 事件循环**
你确定宏任务先执行的吗？我很确信的说，是的，宏任务先执行的。
那你意思是，setTimeout比Promise().then()先执行， 是的。

事件循环（Event Loop）是JavaScript中一种用于处理异步操作的机制。它是JavaScript单线 程执行模型的核心部分，负责协调和处理任务的执行顺序。
JavaScript是一门单线程的语言，意味着它只有一个主线程来执行代码。然而，在实际开发中，我们经常会遇到需要处理异步任务的情况，比如网络请求、定时器和事件处理等。为了不阻塞主线程的执行，JavaScript引入了事件循环机制。
事件循环的基本原理如下：

1．执行栈（Call Stack）：JavaScript代码的执行过程会使用一个执行栈来记录函数调用的顺序和位置。当执行一个函数时，它会被推入执行栈，当函数执行完成后，会从执行栈中弹出。
2．任务队列（Task Queue）：当异步任务完成时，会被放入任务队列中等待执行。常见的异步任务包括定时器回调函数、网络请求的回调函数、事件处理函数等。
3．事件循环（Event Loop）：事件循环是一个持续运行的过程，它不断地检查执行栈和任务队列的状态，并根据一定的规则将任务队列中的任务推入执行栈中执行。事件循环的核心是不断重复以下步骤：
- 检查执行栈是否为空，如果为空，则从任务队列中取出一个任务并推入执行栈中执行。
- 如果执行栈不为空，则继续执行执行栈中的任务。
- 当任务执行完成后，从执行栈中弹出，并检查任务队列是否有新的任务。

这种机制保证了JavaScript中的异步任务按照特定的顺序被执行，避免了阻塞主线程。
具体来说，事件循环按照以下顺序处理任务：

1．执行同步任务：事件循环首先从执行栈中执行所有的同步任务，直到执行栈为空。
2．执行宏任务：事件循环接着检查宏任务队列，如果队列不为空，就从队列中选择一个宏任务推入执行栈中执行。常见的宏任务包括定时器回调、DOM事件回调等。
3．执行微任务：当执行栈中的宏任务执行完毕后，事件循环会检查微任务队列。微任务队列中的任务会立即执行，而不需要等待其他任务。常见的微任务包括Promise的回调函数、 MutationObserver的回调函数等。
4．渲染UI：如果有需要更新的UI，事件循环会进行UI渲染。
5．重复循环：事件循环会再次从宏任务队列开始，重复以上步骤。

因此，宏任务会先执行，而微任务会在宏任务执行完毕后执行。这个顺序保证了宏任务的优先级较低，使得微任务能够快速响应并在每次事件循环中得到执行。

请注意，尽管在大多数情况下宏任务在微任务之前执行，但也有一些特殊情况。例如，在＇setTimeout＇的延迟时间较短的情况下，它的回调函数可能会在某些微任务之前执行。此外，具体的事件循环行为可能因宿主环境而异，如浏览器和Node.js在事件循环实现上有细微的差异。因此，对于特定的应用场景，建议查阅相关的宿主环境文档以了解详细的事件循环机制。非常抱歉之前给您带来的困惑。



## webapck
**webpack的打包流程/原理**重点
```
Webpack 是一个模块打包工具，它可以分析你的项目结构，找到JavaScript模块以及其他的资源（如CSS、图片等），然后将这些资源打包到一些或多个bundle中。

Webpack的打包流程大致如下：
初始化：从配置文件（如webpack.config.js）和Shell语句中读取配置，创建一个初始的构建状态。
确定入口：根据配置中的entry属性确定项目构建的起点。
执行插件：Webpack 插件可以在不同的编译阶段注入自定义的行为，例如：使用webpack插件可以在编译过程中启动一个本地开发服务器。
编译模块：从入口文件开始，Webpack 会逐渐解析出所有依赖的模块，并进行编译。
输出资源：经过编译过的模块会被打包成一个个bundle，以及任何未被打包的资源会被复制到输出目录。

关键词：
2.1 bundle
Bundle（捆绑包）是指将所有相关的模块和资源打包在一起形成的单个文件。它是应用程序的最终输出，可以在浏览器中加载和执行。
捆绑包通常由Webpack根据入口点（entry）和它们的依赖关系自动创建。当你运行Webpack构建时，它会根据配置将所有模块和资源打包成一个或多个捆绑包。

2.2 Chunk
Chunk（代码块）是Webpack在打包过程中生成的中间文件，它代表着一个模块的集合。
Webpack 根据代码的拓扑结构和配置将模块组织成不同的代码块。每个代码块可以是一个独立的文件，也可以与其他代码块组合成一个捆绑包。
Webpack使用代码分割（code splitting）技术将应用程序代码拆分成更小的代码块，以便在需要时进行按需加载。这有助于减小初始加载的文件大小，提高应用程序的性能。
在Webpack中，捆绑包和代码块之间存在一对多的关系。一个捆绑包可以包含多个代码块，而一个代码块也可以属于多个不同的捆绑包。这取决于Webpack配置中的拆分点（split points）和代码块的依赖关系。
总结起来，bundle 是Webpack打包过程的最终输出文件，而chunk是Webpack在打包过程中生成的中间文件，用于组织和按需加载模块。

3.1 Entry
入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。
进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。

3.2 Output
output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。
基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。

3.3 Module
模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。

3.4 Chunk
代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。

3.5 Loader
loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。
loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。
本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。

3.6 Plugin
loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。
插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。
```

**webpack5的模块联邦**重点

Webpack 5 的模块联邦（Module Federation）是一个功能，它允许多个前端应用程序共享模块。这些应用程序可以动态地加载其他应用程序的组件，从而减少代码冗余和提高开发效率。
以下是一个简单的例子，演示如何设置 Webpack 5 的模块联邦。
首先，确保你有两个前端应用程序，我们称之为 app1 和 app2。
在 app1 中，创建一个入口文件 main.js，并使用 webpack 配置来设置模块联邦：ModuleFederationPluging定义联邦模块
在 app2 中，你需要设置 webpack 配置来定义模块联邦，并使用从 app1 共享的组件：new ModuleFederationPlugin中引用
确保你的两个应用程序都在本地服务器上运行，并且 webpack 配置正确地设置了 publicPath，这样模块联盟才能正常工作。
在 app1 和app2中添加启动脚本正常启动

**webpack的热更新原理是怎样的？**
刷新分为两种：一种是页面刷新，不保留页面状态，就是简单粗暴，直接window.location.reload()；另一种只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。
Webpack热更新（ Hot Module Replacement，简称 HMR，后续均以 HMR 替代），无需完全刷新整个页面的同时，更新代码变动的模块，是 Webpack 内置的最有用的功能之一。
HMR 的好处，在日常开发工作中体会颇深：节省宝贵的开发时间、提升开发体验。引用官网的描述来概述一下：
```
HMR 功能会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：

保留在完全重新加载页面期间丢失的应用程序状态。
只更新变更内容，以节省宝贵的开发时间。
在源代码中对 CSS / JS 进行修改，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。
```
热更新开始，new Server() 后会直接调用 server.start()。
可以看到在 start 方法中，即开始进行webSocket服务的初始化。
首先执行的是 setupHooks 方法来注册监听事件的，监听每次 webpack 编译完成，该方式利用的是 webpack 的 done 钩子。
webpack-dev-middleware 内置于 webpack-dev-server，主要是用于监测代码文件变化，处理文件编译等流程。那我们来看下 webpack-dev-middleware 源码里做了什么事。
当 writeToDisk 进行了配置，则进行编译，并将编译后的文件输出到磁盘。
执行 setupOutputFileSystem 方法，这个方法主要目的就是将编译后的文件打包到内存。这就是为什么在开发的过程中，你会发现 dist 目录没有打包后的代码，因为都在内存中。原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销，这一切都归功于memfs。
为什么代码的改动保存会自动编译，重新打包？这一系列的重新检测编译就归功于 compiler.watch 这个方法了，该方法开启对本地文件的监听，当文件发生变化，重新编译，编译完成之后继续监听。监听本地文件的变化主要是通过文件的生成时间是否有变化。


**讲一下webpack的loader和plugin**
- loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中
- plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事
- 从运行时机来看，entry——loaders——output，而plugins贯穿这些阶段始终

开发 plugin
由于 webpack 基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务。钩子函数包括如下部分：
```
（1）entryOption：在entry配置项处理前被调用，可以修改entry配置项；
（2）beforeRun：在运行编译器前被调用；
（3）run：在开始读取记录时被调用；
（4）emit：生成资源到output目录之前被调用；
（5）afterEmit：生成资源到output目录之后被调用；
（6）thisCompilation：在compilation创建之前被调用，可以用于注册额外的插件等；
（7）compilation：在compilation创建时被调用，用于注册一些回调等；
（8）normalModuleFactory：在normal module工厂创建之后被调用，可以在模块加载前完成一些准备工作；
（9）contextModuleFactory：类似于normalModuleFactory，但是用于动态上下文模块；
（10）beforeCompile：编译器开始编译之前被调用；
（11）compile：编译器开始编译时被调用；
（12）afterCompile：编译器完成编译之后被调用；
（13）watchRun：在watch模式编译器运行之前被调用；
（14）failed：当编译失败时被调用；
（15）done：同时编译和重新编译完成后被调用。
```

## 场景
### canvas场景：超市中的货架，上面有很多商品。现在要把这个货架用canvas画出来，商品需要支持一些交互，调整大小，移动位置，你会怎么实现？

### 有一个上线的项目它是vue2写的，如果想升级到vue3，但是没有太多的专用时间来做这件事，此时你会怎么做？

你有开发过不用脚手架的项目吗？

假设要设计一个全局的弹窗组件你会怎么设计？

如果这个弹窗组件可以弹出多个，消息会垂直排列，新消息会把旧消息顶起来，每个消息都可以设置一个停留时间，到了时间后就会消失，这一块你会怎么设计？

你了解堆这种数据结构吗？讲一讲你对它的理

### 如何看待前后端分离开发
后段：业务逻辑复杂，表设计要建好，遇到千万级数据，索引要建好，或者上nosql，如果并发大还要做限流、缓存等，微服务还要做etcd（分布式键值存储系统，etcd 强一致和 Redis最终一致）、链路追踪等。
前端：如果对设计要求高，那要搭组件库，数据统计还要用chart，双端还要自适应或者做两套，各种浏览器兼容，要求首页快或者seo，那又得上ssr（服务器端渲染），微前端要样式隔离（scoped实现样式隔离和），store传输等。都还没说android ios，而且前端低代码、无代码编辑器更复杂。
总结下来两个没有可比性，前端面向用户，注重用户交互、体验等。而后端面向数据注重接口速度、并发。


## Babel
讲一下Babel的原理，讲一下AST抽象语法树

## 浏览器
**浏览器的垃圾回收机制（V8的垃圾回收机制）**重点

**浏览器的渲染流程**重点
讲一下浏览器多进程的渲染优势
谈谈你对浏览器架构的理解

大文件分块上传以及断点续传，你会怎么实现
你刚才说你写了个web端的截图插件，你能讲一下你是怎么实现的吗？
我看你上家公司是做动画编辑器的，你在做这个项目的时候有遇到过哪些难点吗？
你刚才提到了你为编辑器做了一些性能优化，你都做了哪些优化？
你刚才说你还实现了svg类型的文本组件搜索功能，你能讲讲你是如何实现的
编辑器的性能优化，你具体是怎么做的？
编辑器前端编辑的应该是dom吧，最后生成的视频是怎么生成的？

## SEO
seo优化有了解过吗？讲一下你的见解

如何实现一个响应式网站？
用css3的媒体查询来实现，如果移动端跟PC端布局差异很大的话，就写两套页面，对应两个域名，服务端根据http请求头判断设备类型来决定是否要重定向到移动端。

## 响应式网站
在seo优化方面，前端要从哪些点去考虑？
标签语义化、ssr服务端渲染、img标签添加alt属性来、在head中添加meta标签、优化网站的加载速度，提高搜索引擎的排名。


### 在前端vue项目里,为什么登录逻辑需要写在用户store文件里？
写在 store 里面做全局状态管理，不是因为登录逻辑本身的原因，而是因为登录本身的状态，百分之 99 的情况下，都是全局状态，即系统的认证态和匿名态。

根据这个前提，衍生出来的常见需求点有很多，随便列举几个：
- 如果用户在匿名态下，直接进入需要认证态的页面，需要怎么处理？
- 用户已经在认证态页面，之后因凭证过期，突然进入匿名态，需要怎么处理？
- TO B 系统常见的权限分级场景，不同用户可以可见不同的导航栏项目，在权限发生变化时，需要怎么处理当前的鉴权状态？
- 等等等...
所以这个事儿的核心原因在于全局状态管理需要放入 store 中，而恰恰登录逻辑中涉及的状态都具有全局性质，自然就经常放到 store 文件中了。

## 算法题

### 实现一个深拷贝函数

### 写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式。





