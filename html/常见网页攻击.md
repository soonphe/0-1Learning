# 0-1Learning

![alt text](../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../static/common/svg/luoxiaosheng_wechat.svg "微信")


## 常见网页攻击

### 目录
- [什么是CSRF攻击](#什么是CSRF攻击)
   - [如何防止CSRF攻击](#如何防止CSRF攻击)
- [XSS攻击](#XSS攻击)
  - [XSS的防御](#XSS的防御)
- [DDos攻击防护思路](#DDos攻击防护思路)
   - [DDos攻击防护思路](#DDos攻击防护思路)
- [为什么token可以防止csrf攻击](#为什么token可以防止csrf攻击)
- [Referer-Policy](#Referer-Policy)


### 什么是CSRF攻击
CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事

如何模拟 CSRF 攻击

1. 自动发起 Get 请求
   黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户的钱就被转移到黑客的账户上去了。

2. 自动发起 POST 请求
   黑客在他的页面中构建了一个隐藏的表单，假设为转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。

3. 引诱用户点击链接
   除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。
   黑客会采用很多方式去诱惑用户点击链接，如页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的钱就被转到黑客账户上了。

#### 如何防止CSRF攻击
发起 CSRF 攻击的三个必要条件：

第一个，目标站点一定要有 CSRF 漏洞；
第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；
第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。
满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。

要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。

1. 充分利用好 Cookie 的 SameSite 属性
   通过上面的介绍，相信你已经知道了黑客会利用用户的登录状态来发起 CSRF 攻击，而Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。
   通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：

如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；
如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。
而我们要聊的 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。

那 SameSite 是怎么防止 CSRF 攻击的呢？

在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：

SameSite 选项通常有 Strict、Lax 和 None 三个值。

Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从A网站页面中访问 B网站资源，而 B网站 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 B网站 的服务器上的。只有你从 B网站 的站点去请求 B网站 的资源时，才会带上这些 Cookie。
Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

> 对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。

2. 验证请求的来源站点
   由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？

这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。

Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下图：

虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考Referrer Policy

但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：

Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。

因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

4. CSRF Token
   第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串返回。
   第二步，在浏览器端如果要发起转账的请求，那么需要带上 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。



### XSS攻击
XSS攻击（Cross Site Scripting），攻击者向Web页面里插入恶意Script代码，当用户浏览该页面时，，嵌入到Script的代码被执行，达到恶意攻击的目的。

反射型XSS攻击流程：
1.发送连接。
2.用户点击恶意连接。
3.网站将XSS同正常的网页返回到用户的浏览器。
4.用户的浏览器解析了网页中的恶意代码，向恶意服务器发起请求。
5.黑客从自己搭建的恶意服务器获取用户的相关信息。
需要欺骗用户自己去点击恶意连接才能触发XSS代码。大多时用来盗用cookie的。非持久化。

存储型XSS攻击流程：
1.黑客在目标服务器上构造XSS恶意脚本，保存在数据库中。
2.用户在网站登录状态下，访问了目标服务器，查看了存在恶意脚本的页面。
3.网站将XSS同正常的页面返回到用户的浏览器上。
4.用户的浏览器解析了网页中的恶意代码，向恶意服务器发起请求。
5.黑客从自己搭建的恶意服务器获取用户的相关信息。
持久化，代码时存储在服务器中的，例如：在个人信息或发表文章等地方，插入恶意代码，如果没有过滤或者过滤不严的话，那么这些恶意代码就会存储到服务器中，用户访问该页面时触发代码执行。比较危险，容易造成蠕虫，盗窃cookie

#### XSS的防御
对用户输入的信息和URL的参数进行过滤
对输出的行进行HTML编码
服务端设置会话cookie的HTTP Only 中的属性，使客户端的JS脚本就不能获取cookie信息了。
对用户提交的信息进行过滤，会过滤掉导致脚本执行的相关内容。
对动态输出到页面的内容进行HTML编码，使脚本无法执行。



### DDOS网络攻击
DDos的基本概念及类型

Dos拒绝服务攻击是通过各种手段消耗网络带宽和系统CPU、内存、连接数等资源，直接造成网络带宽耗尽或系统资源耗尽，使得该目标系统无法为正常用户提供业务服务，从而导致拒绝服务。DDos分布式拒绝服务攻击由Dos演变而来，黑客利用控制的多台计算机（肉鸡）对一个特定目标发送尽可能多的网络访问请求，形成流量洪流来冲击目标业务系统，其攻击源是分散的、范围可能遍布全球。信息安全的三要素——“保密性”“完整性”和“可用性”中，传统拒绝服务攻击针对的目标正是系统“可用性”。

DDos攻击主要分为两大类：流量攻击型和应用攻击型。

- 流量型攻击最大的特点就是流量大，快速消耗用户的网络带宽造成带宽耗尽，可能出现一个特定目标单位被攻击影响到共用运营商资源的其他单位带宽受影响的情况。流量型DDos又可分为直接型和反射型，直接型主要包括SYN\ACK\ICMP\UDPFLOOD等，反射型主要包括NTP\DNS\SSDP反射FLOOD等。

- 应用型DDos攻击最典型的就是CC攻击和HTTP慢速攻击，CC是DDos攻击的一种，CC攻击是借助代理服务器生成指向受害主机的合法请求，实现DDOS和伪装，CC攻击（ChallengeCollapsar）要是通过制造大量的后台数据库查询动作来攻击页面，消耗目标资源；HTTP慢速攻击是CC攻击的变种，对任何一个开放了HTTP访问的服务器，攻击者先建立一个连接，指定一个比较大的content-length，然后以非常低的速度发包，比如1-10s发一个字节，然后维持住这个连接不断开。如果客户端持续建立这样的连接，那么服务器上可用的连接数将一点一点被占满，从而导致拒绝服务。CC攻击、慢速攻击等应用型攻击与流量型DDos的区别就是流量型DDos是针对IP的攻击，而CC攻击的是服务器资源。

下面是典型的 SSDP DDoS 攻击的 6 个步骤：
首先，攻击者进行扫描，寻找可以用作放大因子的即插即用设备。
攻击者发现联网设备后，创建所有发出响应的设备的列表。
攻击者使用目标受害者的欺骗性 IP 地址创建<a href="https://www.cloudflare.com/zh-cn/learning/ddos/glossary/ip-spoofing"> UDP 数据包。
然后，攻击者使用僵尸网络通过设置某些标志（比如 ssdp:rootdevice 或 ssdp:all），向每个即插即用设备发送一个欺骗性发现数据包，并请求尽可能多的数据。
结果，每个设备都会向目标受害者发送回复，其数据量最多达到攻击者请求的 30 倍。
然后，目标从所有设备接收大量流量，因此不堪重负，可能导致对正常流量拒绝服务。


#### DDos攻击防护
- 流量型DDos攻击防护思路
1. 本地DDos防护设备。
2. 运营商清洗服务。
3. 云清洗服务。

以上三种防御方式存在共同的缺点，由于本地DDos防护设备及运营商均不具备HTTPS加密流量解码能力，导致针对HTTPS流量的防护能力有限；同时由于运营商清洗服务多是基于Flow的方式检测DDos攻击，且策略的颗粒度往往较粗，因此针对CC或HTTP慢速等应用层特征的DDos攻击类型检测效果往往不够理想。

- 应用型DDos攻击防护思路

这里要重点介绍一下CC攻击。CC攻击是一个依赖http协议，并通过构造特殊的http请求导致服务器保持连接等待状态，直至服务器CPU、内存、连接数等资源被打满，从而造成拒绝服务的一种攻击方式，属于典型的应用层DDos攻击。CC攻击的特点和流量型DDoS攻击最大的区别是并不需要大流量即可达到攻击效果。有些极端情况下在遭受此类攻击的时候，流量特征可能没有明显的变化，而业务层面出现访问缓慢、超时等现象，且大量访问请求可能指向同一个或少数几个页面。

因为CC攻击来的IP都是真实的、分散的，且CC攻击的请求，全都是有效的请求，无法拒绝的请求。对于此类攻击，DDoS攻击清洗设备的基础算法作用可能就没那么明显了，需要在攻击过程中实时抓取攻击特征，对症下药。

总结CC攻击，发生攻击时还是有较明显的攻击特征。一般情况客户在访问业务的时候不会集中在几个页面，而是比较分散的。而当发生了CC攻击的时候，抓包后可以很明显地发现大量的访问都集中在某几个或者多个页面，那么我们可以针对该特征进行针对性地防护配置。

- CC攻击的防护思路

由于CC攻击是典型的应用层DDos攻击，因此传统安全设备，如防火墙、运营商清洗等很难起到很好的防护作用。目前业界通常会在应用服务器前端部署具备安全功能的代理设备进行防护，比如WAF、负载均衡等，避免让服务器直接面对CC攻击。代理设备启用资源代理和安全防护功能，比如要求在接收完整的HTTP请求之后才会与服务器建立TCP连接并发送已收到的HTTP请求，此时攻击者的请求直接被代理设备终结而不会发往服务器。

经过实践总结，前端WAF或者负载均衡设备能够提供的有效策略如下：

一是部署架构上，可将前端WAF或者负载均衡设备部署于HTTPS卸载器之后，从而实现对HTTPS流量的防护能力。

二是使用IP地址信誉库，对请求IP地址进行甄别和过滤，阻止来自恶意IP的服务请求。

三是通过跟踪客户端的Session信息、标记Session的威胁指数与可疑度、识别访问频度、鼠标键盘操作时间等技术，识别恶意请求；同时制定挑战策略，对于不合法的请求可以采取挑战验证码、识别机器人行为特征，快速阻断不合法请求或BOT发起的仿正常请求。

系统/应用层面能够提供的有效防护策略有：

一是轻应用部署。应用部署时考虑页面静态比例，尽量让网站静态化，减少不必要的动态查询等方式，同时应急情况下可以将动态页面临时替换为静态页面，减少后台请求数据库/应用服务器的次数。

二是限制单IP连接数量，降低同一ip攻击者带来的危害和影响。

三是降低连接超时时间，及时释放系统资源应对TCP连接资源耗尽类型的CC攻击。

四是及时清理无用过期等文件，并将大的文件对象或者页面部署在CDN节点上，隐藏真正的互联网带宽入口，降低对源站的影响等。

以上防护手段可以起到一定的防护作用。不过，我们也要看到，目前黑客攻击有多样化的趋势，一次攻击行为内往往混合了多种攻击方式和手段。金融机构需要抵御这种凶猛的攻击，靠单独的某一类设备是不够的。金融机构应该搭建层次化的立体防御架构，防范攻击需要在合适的维度采用合适的防御技术，且每个防御层面都需要充分考虑其架构可扩展性，架构上需要仔细考量与设计。


### 为什么token可以防止csrf攻击
1. cookie同源请求携带
2. 钓鱼请求和系统内部正常请求有区别，系统内部发送请求是通过内部方法带上token，你点击钓鱼链接发送的请求是不带token的，但是会带cookie信息。

cookie是发起同源请求自动携带的，假设你登录了建行网站，浏览器会存储下cookie,这个时候恶意网站向建行发送请求，浏览器会自动把你cookie带上，这个行为很危险，因为建行后台可能由根据的cookie判断是你自己发起的，返回一些敏感数据或者做一些转账操作就坏了。

token是在你登录的时候，后台返给你的，而且是你自己存储在内存中的，请求的时候也是自己加header上的，所以安全一点。

假设还是刚才那个例子，恶意网站发请求想带token,怎么才能拿到token? 1.从你内存里拿?不太可能。2.登录去拿?那得知道你用户名密码，这个知道了啥不能干，还用伪造吗？一般就是不可能知道。


### Referer-Policy
Referer-Policy 包括以下几个可选项

no-referrer
整个 Referer 首部会被移除。访问来源信息不随着请求一起发送。

no-referrer-when-downgrade （默认值）
在同等安全级别的情况下，引用页面的地址会被发送(HTTPS->HTTPS)，但是在降级的情况下不会被发送 (HTTPS->HTTP)。

origin
在任何情况下，仅发送文件的源作为引用地址。例如 https://example.com/page.html 会将 https://example.com/ 作为引用地址。

origin-when-cross-origin
对于同源的请求，会发送完整的URL作为引用地址，但是对于非同源请求仅发送文件的源。

same-origin
对于同源的请求会发送引用地址，但是对于非同源请求则不发送引用地址信息。

strict-origin
在同等安全级别的情况下，发送文件的源作为引用地址(HTTPS->HTTPS)，但是在降级的情况下不会发送 (HTTPS->HTTP)。

strict-origin-when-cross-origin
对于同源的请求，会发送完整的URL作为引用地址；在同等安全级别的情况下，发送文件的源作为引用地址(HTTPS->HTTPS)；在降级的情况下不发送此首部 (HTTPS->HTTP)。

unsafe-url
无论是同源请求还是非同源请求，都发送完整的 URL（移除参数信息之后）作为引用地址。

Referer-Policy 默认值
如果 Referer-Policy 未设置任何策略，则使用浏览器的默认值。网站通常会遵循浏览器的默认设置。

对于导航和 iframe, Referer 头中的数据也可以通过 JavaScript 使用 document.referrer 访问。

no-referrer-when-downgrade 是跨浏览器的一种广泛的默认策略。但是现在，许多浏览器正处于向更多提高隐私的默认设置过渡的阶段。

Chrome 计划在85版开始 将其切换默认策略 no-referrer-when-downgrade 更换到 strict-origin-when-cross-origin。

变化
strict-origin-when-cross-origin 提供更多的隐私。有了这个政策，Referer 标头只会发送 origin

这样可以防止泄漏私人数据，这些数据可以从完整URL的其他部分（例如路径和查询字符串）访问。

例如，在一个跨域请求中：

从 https://site-one.example/stuff/detail?tag=red 访问 https://site-two.example/…

使用 no-referrer-when-downgrade: Referer: https://site-one.example/stuff/detail?tag=red。
使用 strict-origin-when-cross-origin: Referer: https://site-one.example/。

不变的
和 no-referrer-when-downgrade 一样， strict-origin-when-cross-origin 在从 HTTPS 来源访问 HTTP 站点时，不会携带 Referer 头。
在相同的来源内，Referer 标头值为完整的 URL 。