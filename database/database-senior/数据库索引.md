# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")


## 数据库索引

### 索引是什么
索引:索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构
SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引
MySQL 索引类型有：唯一索引，主键（聚集）索引，非聚集索引，全文索引。
聚合索引:数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引
InnoDB普通索引的叶子节点存储主键值。

索引回表：基于非主键索引的查询需要多扫描一棵索引树，即先扫描非主键索引定位主键值，再扫描主键聚集索引查询记录

### 如何创建索引
CREATE INDEX 实例
本例会创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 列：
CREATE INDEX PersonIndex
ON Person (LastName) 
如果您希望以降序索引某个列中的值，您可以在列名称之后添加保留字 DESC：
CREATE INDEX PersonIndex
ON Person (LastName DESC) 
假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：
CREATE INDEX PersonIndex
ON Person (LastName, FirstName)


### 正排索引和倒排索引
1.正排索引： 由文档指向关键词
 文档--> 单词1 ,单词2
单词1 出现的次数  单词出现的位置； 单词2 单词2出现的位置  …
以文档id为key，搜索全部文档，查询效率低，易维护
 
2.倒排索引： 由关键词指向文档
单词1--->文档1,文档2，文档3
单词2--->文档1，文档2
以关键词为key，查询效率高


###  索引模糊查询
mysql在使用like查询中，能不能用到索引？在什么地方使用索引呢？
可以，但只有使用后面的%时，才会使用到索引

### 联合索引：
符合最左原则，将最常用的列放在最左边，依次递减
例：创建a,b,c联合索引，等价于abc，ab，a索引

两个或更多个列上的索引被称作复合索引。
利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。
复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
如果您知 道姓，电话簿将非常有用；
如果您知道姓和名，电话簿则更为有用，
但如果您只知道名不姓，电话簿将没有用处。


### 使用索引注意事项：
1.不要过度索引，例如性别只有两个值，建索引不仅没什么优势，还会影响到更新速度
2.复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的
3.单个索引需要注意的事项，组合索引全部通用。
4.比如索引列不要参与计算啊、or的两侧要么都索引列，要么都不是索引列啊、模糊匹配的时候%不要在头部啦等等

Order by排序是否走索引：当order by 中的字段出现在where条件中时，才会利用索引而不排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。

### 索引回表和覆盖索引
例：定义索引 index(name)
回表查询：先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。
select id,name,sex from user where name='shenjian';
能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫码聚集索引获取sex字段，效率会降低

覆盖索引：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
select id,name from user where name='shenjian';
能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

前缀索引：对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。
例：ALTER TABLE table_name ADD KEY(column_name(prefix_length));


### 索引优化？为什么要建立多个索引
首先不管你建立的索引有多少，执行查询的时候只会执行一个索引 那么为什么还要建立很多索引？
是因为查询条件不同 不同的条件就会执行不同的索引所以要建立多个。

force index()指令可以指定本次查询使用哪个索引！一条sql只会用到一个索引，mysql优化器会计算出一个合适的索引，但是这个索引不一定是最好的。
force index()指令可以避免MySql优化器用到了一个低效的索引。
例：
```
select customer,count(1) c  
from upv_1  force index(idx_created)  
where created between "2015-07-06" and "2015-07-07"  
```

### SQL语句的执行计划Explain
例：explain select * from emp where name = 'Jefabc';

expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra
详细分析：
* id:选择标识符，SELECT的查询序列号
* select_type:表示查询的类型。
    (1) SIMPLE(简单SELECT，不使用UNION或子查询等)
    (2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
    (3) UNION(UNION中的第二个或后面的SELECT语句)
    (4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
    (5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
    (6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
    (7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
    (8) DERIVED(派生表的SELECT, FROM子句的子查询)
    (9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

* table:输出结果集的表
* partitions:匹配的分区
* type:表示表的访问类型，
常用的类型有： ALL、index、index_merge、range、index_subquery、unique_subquery、ref_or_null、fulltext、ref、eq_ref、const、system、NULL（从左到右，性能从差到好）
除了all以外，其余的type均可以使用到索引，除了index_merge以外，其余的type只能够用到一个索引
```
    ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
    index: Full Index Scan，index与ALL区别为index类型只遍历索引树
    index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不一样的索引，官方排序这个在ref_or_null以后，可是实际上因为要读取所个索引，性能可能大部分时间都不如range
    range:只检索给定范围的行，使用一个索引来选择行
    index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可使用索引将子查询去重。
    unique_subquery：用于where中的in形式子查询，子查询返回不重复值惟一值
    ref_or_null：与ref方法相似，只是增长了null值的比较。实际用的很少。
    fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql无论代价，优先选择使用全文索引
    ref: 不像eq_ref那样要求链接顺序，也没有主键和惟一索引的要求，只要使用相等条件检索时就可能出现，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
    eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件且必须为not null，惟一索引和主键是多列时，只有全部的列都用做比较时才会出现eq_ref
    const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system
    NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
```
* possible_keys:表示查询时，查询涉及到的字段上若存在索引，则该索引将被列出，可能使用的索引，不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）
* key:表示实际使用的索引，select_type为index_merge时，这里可能出现两个以上的索引，其余的select_type这里只会出现一个。
* key_len:索引字段的长度
* ref:列与索引的比较，若是是使用的常数等值查询，这里会显示const，若是是链接查询，被驱动表的执行计划这里会显示驱动表的关联字段，若是是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func
* rows:扫描出的行数(估算的行数)
* filtered:按表条件过滤的行百分比
* Extra:执行情况的描述和说明
经常使用的有
```
A：distinct：在select部分使用了distinc关键字
B：no tables used：不带from字句的查询或者From dual查询
C：使用not in()形式子查询或not exists运算符的链接查询，这种叫作反链接。即，通常链接查询是先查询内表，再查询外表，反链接就是先查询外表，再查询内表。
D：using filesort：排序时没法使用到索引时，就会出现这个。常见于order by和group by语句中
E：using index：查询时不须要回表查询，直接经过索引就能够获取查询的数据。
F：using join buffer(block nested loop)，using join buffer(batched key accss)：5.6.x以后的版本优化关联查询的BNL，BKA特性。主要是减小内表的循环数量以及比较顺序地扫描查询。
G：using sort_union，using_union，using intersect，using sort_intersection：
using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集
using union：表示使用or链接各个使用索引的条件时，该信息表示从处理结果获取并集
using sort_union和using sort_intersection：与前面两个对应的相似，只是他们是出如今用and和or查询信息量大时，先查询主键，而后进行排序合并后，才能读取记录并返回。
```

补充说明：
• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
• EXPLAIN不考虑各种Cache
• EXPLAIN不能显示MySQL在执行查询时所作的优化工作
• 部分统计信息是估算的，并非精确值
• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划

### 为什么mysql不用hash索引
大多数索引（如 PRIMARY KEY,UNIQUE,INDEX和FULLTEXT）都是在BTREE中存储，但使用memory引擎可以选择BTREE索引或者HASH索引，
Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。
既然Hash索引相比B-Tree索引的效率要高，那么，为什么在实际开发应用过程中，为什么普遍使用B-Tree索引，而不是Hash索引呢？
1. select范围查询：”=”,”IN”和”<=>”查询

    由于Hash索引比较的是进行Hash运算之后的Hash值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样。
2. 不能排序

   Hash 索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
3. Hash 索引不能利用部分索引键查询

   对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
4. 索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，分批的话比B+树io次数多的多，B+树的设计可以允许数据分批加载，同时树的高度较低，磁盘io次数少，提高查找效率

5. hash冲突退化为表扫描遍历

   Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。


### 为什么红黑树出现了，B树相对于红黑树的区别
hash索引o(1)   B＋树索引 o(logn)
为什么红黑树出现了，因为防止某些情况下二叉排序树退化为链表——诞生了二叉排序平衡树——树的性能取决于树的高度
为什么DB要用M路B树，为了再降低树的高度，减少db 磁盘io 次数，如果在内存中，红黑树效率更高
为什么M不能无限大，因为会退化成有序数组，无法一次载入内存，B树则可以一次加载一个节点
B＋树在B树的基础上，(1)仅在叶子节点存放数据——B树高度更大；(2)同时叶子节点链表——避免跨层范围查找
在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。


### 为什么Mysql用B+树作为索引的存储结构，为什么Mysql用B+树做索引而不用B-树
B-树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。
数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。 正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）
同样高度的B-Tree和B+Tree中，B-Tree查找某个关键字的效率更高。但在找大于某个关键字或者小于某个关键字的数据的时候，由于B+Tree所有的数据都在叶子结点，并且结点之间有指针连接，B+Tree只需要找到该关键字然后沿着链表遍历就可以了，而B-Tree还需要遍历该关键字结点的根结点去搜索。
由于B-Tree的每个结点(这里的结点可以理解为一个数据页)都存储主键+实际数据，而B+Tree非叶子结点只存储关键字信息，而每个页的大小有限是有限的，所以同一页能存储的B-Tree的数据会比B+Tree存储的更少。这样同样总量的数据，B-Tree的深度会更大，增大查询时的磁盘I/O次数，进而影响查询效率(针对聚簇索引主键索引)。


### mysql索引树高度/索引层数常见问题
- 一个表有3000万记录，假如有一列占8位字节的字段，根据这一列建索引的话索引树的高度是多少？

    计算公式：表的记录数是N， 每一个BTREE节点平均有B个索引KEY 那么B+TREE索引树的高度就是logNB(等价于logN/logB)
    3000W条记录（因为2^25=33554432），如果每个节点保存64个索引KEY,那么索引的高度就是（log2^25)/log64≈ 25/6 ≈ 4.17

备注：由于索引树每个节点的大小固定，所以索引KEY越小，B值就越大，那么每个BTREE节点上可以保存更多的索引KEY，也就是B值越大，索引树的高度就越小，那么基于索引的查询的性能就越高。所以相同表记录数的情况下，索引KEY越小，索引树的高度就越小。

要计一张表索引树的高度，只需要知道一个节点有多大，从而就能知道每个节点能存储多少个索引KEY，现代数据库经过不断的探索和优化，并结合磁盘的预读特点，每个索引节点一般都是操作系统页的整数倍，操作系统页可通过命令得到该值得大小，且一般是4094，即4k。而InnoDB的pageSize可以通过命令得到，默认值是16k。
以BIGINT为例，存储大小为8个字节。INT存储大小为4个字节（32位）。索引树上每个节点除了存储KEY，还需要存储指针。所以每个节点保存的KEY的数量为pagesize/(keysize+pointsize)（如果是B-TREE索引结构，则是pagesize/(keysize+datasize+pointsize)）。
假设平均指针大小是4个字节，那么索引树的每个节点可以存储16k/((8+4)*8)≈171。那么：一个拥有3000w数据，且主键是BIGINT类型的表的主键索引树的高度就是(log2^25)/log171 ≈ 25/7.4 ≈ 3.38。
假设平均指针大小是8个字节，那么索引树的每个节点可以存储16k/((8+8)*8)≈128。那么：一个拥有3000w数据，且主键是BIGINT类型的表的主键索引树的高度就是(log2^25)/log128 ≈ 25/7 ≈ 3.57
**一个千万量级，且存储引擎是MyISAM或者InnoDB的表，其索引树的高度在3~5之间。**


- 为什么mysql到了两千万之后性能下降？
两千多万是整数id作为主键，三层放得下。然后把所有的索引节点都放在内存中也就是一点点。这样查询过程内存操作忽略不计，取数据一次io，一旦变4层 单机内存不太可能全部放的下了，查询过程的io实打实访问磁盘去了，所以会慢一点，看使用场景，低频访问io次数总体不高的情况没啥区别
当索引树层数增加了，磁盘扫描IO次增加了。 B+ 树来查找会首先找到根页，然后在非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据
InnoDB的B+树索引的结点就是InnoDB的数据页，查找数据时一次页的查找代表一次 IO，一次性运一个结点进内存，然后在内存中二分查找、遍历找到对应记录，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。
换ssd硬盘可以提升IO能力，高性能rds都是ssd
