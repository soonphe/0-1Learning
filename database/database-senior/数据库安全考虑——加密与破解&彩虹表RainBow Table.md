# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")


## 数据库安全考虑

### 设计一个合理的DB：
用户表与密码表分开，表名加密，数据加密
同密码的hash码不同，防止字典攻击，
密码：使用动态salt


### 常见的破解方式
暴力攻击：给定长度，尝试每一种可能性
字典攻击：将常用的都放在一个文件中，不停的hash对比（取决字典大小以及字典是否合理）

查表破解：预先计算出密码字典中每一个密码的hash（设计查询器，提高查询效率）
反向查表破解：根据获取的数据库数据 做一个与用户名对应的hash表，然后将常用的字典密码hash之后跟这个表对比

彩虹表：使用空间换时间的技术，与查表破解相似，牺牲一些时间来达到更小的存储空间（已经能够破解8位任意字符的md5hash）

————————————————————————————————————————————————————————
哈希定律：只需要知道首尾，中间推算
————————————————————————————————————————————————————————

加盐：add salt
  查表破解和彩虹表之所以能够有效，因为每一个密码都使用相同的方式hash
  解决：每一个hash随机化，加 salt，同一个密码hash两次

注：
  错误用法：
	一个salt在多个hash中使用或使用的salt很短

短的盐：例，3位ASCII码，一共 95×95×95=857,375可能，再为每一个salt制作一个包含1MB的常见密码表，一共才837G，所以。。。

注：不要用用户名做salt
    盐的大小要跟hash函数一致，如：
SHA26的输出是256bits（32bytes），所以的salt的长度也应该为32位随机字符串

salt要使用密码上可靠些的伪随机数生成器
如：java：java.security。

——————————————————————————————————————
存储一个密码：
1.生成一个随机Salt
2.salt和密码拼接，使用标准hash函数加密
3.将salt和hash记录在数据库

验证一个密码：
1.从数据库取出用户的salt和hash
2.用密码和salt用相同的方式拼接在一起，使用相同的hash
3.比对

客户端hash
1.客户端密码并不是https（SSL/TLS）的替代品
2.部分浏览器可能不支持javascript，要判断模拟客户端的hash
3.客户端hash也要加盐，但不能是请求服务器得到用户的盐（防止验证）
