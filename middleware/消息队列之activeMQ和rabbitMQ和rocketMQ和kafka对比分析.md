# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")


## 消息队列

### 消息队列的作用
1.解耦
2.最终一致性
3.广播（只关注消息是否送到队列，至于谁订阅，那是下游的事情）
4.错峰和流控

### 主流MQ比较

|特性	| activeMQ	| rabbitMQ	| rocketMQ	| kafka |
| ---- | ---- | ---- | ---- | ---- |
|单机吞吐量	|万/秒	|万/秒	|10万/秒	|10万/秒|
|topic对吞吐量的影响	|无	|无	|topic达到几百/几千个级别，吞吐量会有小幅下降；这是rocket的最大优势所以非常适用于支撑大批量topic场景	topic可以达到几十/几百个级别，吞吐量会有大幅下降  |kafka不适用大批量topic场景，除非加机器|
|时效性	|毫秒	|微秒 这是rabbit 最大优势，延迟低|	毫秒	|毫秒|
|可用性	|高。主从架构|	高。主从架构	|非常高。分布式。	|非常高。分布式。数据多副本，不会丢数据，不会不可用。|
|可靠性	|有较低概率丢失数据|	----	|经配置优化可达到0丢失|	经配置优化可达到0丢失|
|功能特性|	功能齐全，但已不怎么维护|	erlang开发，并发强，性能极好，延迟低|	MQ功能较为齐全，扩展好|	功能简单，主要用于大数据实时计算和日志采集，事实标准|

Active：官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。

Kafka：——Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输
 性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。
 时效性：ms级
 可用性：非常高，kafka是分布式的，通过控制能够保证所有消息被消费且仅被消费一次;
 在日志领域比较成熟，被多家公司和多个开源项目使用；
 功能支持：在大数据领域的实时计算以及日志采集被大规模使用
缺点：
 Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长；
 使用短轮询方式，实时性取决于轮询间隔时间；
 消费失败不支持重试；
 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；
 社区更新较慢；

RabbitMQ缺点：——结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，適合数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。
erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护
RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。
需要学习比较复杂的接口和协议，学习和维护成本较高。

RocketMQ缺点：——天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的
支持的客户端语言不多，目前是java及c++，其中c++不成熟；
社区活跃度一般；
没有在 mq 核心中去实现JMS等接口，有些系统要迁移需要修改大量代码 。