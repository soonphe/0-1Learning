# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")


## 自定义注解和注解处理器

### 注解语法要求
* 修饰符
  * 访问修饰符必须为public,不写默认为pubic；
* 关键字
  * 关键字为@interface；
* 注解名称
  * 注解名称为自定义注解的名称，使用时还会用到；
* 注解类型元素
  * 注解类型元素是注解中内容，可以理解成自定义接口的实现部分；

### 其他元注解

* @Target
    示例：@Target({ElementType.METHOD,ElementType.TYPE})	    

|Target类型	|描述|
| ---- | ---- |
|ElementType.TYPE	|应用于类、接口（包括注解类型）、枚举|
|ElementType.FIELD	|应用于属性（包括枚举中的常量）|
|ElementType.METHOD	|应用于方法|
|ElementType.PARAMETER	|应用于方法的形参|
|ElementType.CONSTRUCTOR	|应用于构造函数|
|ElementType.LOCAL_VARIABLE	|应用于局部变量|
|ElementType.ANNOTATION_TYPE	|应用于注解类型|
|ElementType.PACKAGE	|应用于包|
|ElementType.TYPE_PARAMETER	|1.8版本新增，应用于类型变量）|
|ElementType.TYPE_USE	|1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）|

* @Retenttion
    示例：@Retenttion(RetentionPolicy.RUNTIME)	

|生命周期类型	|描述|
| ---- | ---- |
|RetentionPolicy.SOURCE	|编译时被丢弃，不包含在类文件中|
|RetentionPolicy.CLASS	|JVM加载时被丢弃，包含在类文件中，默认值|
|RetentionPolicy.RUNTIME	|由JVM 加载，包含在类文件中，在运行时可以被反射获取到|

* @Inherited	//允许子类继承

* @Document	//生成javaDoc时会包含注解

### 示例
~~~~

@Target({ElementType.METHOD,ElementType.TYPE})
@Retenttion(RetentionPolicy.RUNTIME)
@Inherited
@Document
Public @interface XXX{	//使用@interface关键字定义注解

  //成员类型是受限的：原始类型，String，Class，Annotation，Enumeration
  //如果注解只有一个成员，则成员名必须取名为value();
  //注解类可以没有成员，没有成员的注解为标识注解
String XX();	//成员已无参无异常方式声明 
int age() default 18;	//可以用default为成员指定一个默认值

}
~~~~

### 注解是怎么生效的
通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑

### 注解处理器
注解处理器（Annotation Processor）是javac的一个工具，不管是运行时注解还是编译时注解，都会通过处理器在编译时进行扫描和处理注解。
Java中有默认的注解处理器，使用者也可以自定义注解处理器，注册后使用注解处理器处理注解，最终达到注解本身起到的效果。

注解处理器将标记了注解的类，变量等作为输入内容，经过注解处理器处理，生成想要生成的java代码。所以处理器可以理解为就是一个生成代码的工具，只是是通过注解的规则生成。生成后的代码，可以看作是同一般代码，最终被编译。

#### 自定义注解处理器
AbstractProcessor在JDk的rt,jar中：
**继承虚处理器AbstractProcessor**
**实现init、process、getSupportedAnnotationTypes、getSupportedSourceVersion方法**
```
public class RouterProcessor  extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        return false;
    }

    @Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment);
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return super.getSupportedAnnotationTypes();
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return super.getSupportedSourceVersion();
    }
}
```
- init(ProcessingEnvironment processingEnvironment):
  每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements, Types和Filer。后面我们将看到详细的内容。
- process(Set<? extends TypeElement> annotations, RoundEnvironment env):
  这相当于每个处理器的主函数main()。扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。
- getSupportedAnnotationTypes():
  这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。
- getSupportedSourceVersion():
  用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。然而，如果你有足够的理由只支持Java 6的话，你也可以返回SourceVersion.RELEASE_6。我推荐你使用前者。
在Java 7中，你也可以使用注解来代替getSupportedAnnotationTypes()和getSupportedSourceVersion()，像这样：
@SupportedAnnotationTypes(“com.starcor.annotation.RouterAnnotation”)，其中括号内内容表示要处理的注解名称，要写全名。

**注册处理器**
以上已经把完成了处理器的工作，但是处理器要被识别 ，还需要被注册。
- 注册方式一：手动注册 

  在使用注解处理器需要先声明，步骤：
  1. 需要在 processors 库的 main 目录下新建 resources 资源文件夹；
  2. 在 resources文件夹下建立 META-INF/services 目录文件夹
  3. 在文件java.lang.Process中增加注册器路径名： com.starcor.processor.router.RouterProcessor

- 方式二：自动注册

  google提供了一个注册处理器的库AutoService。帮助将要编译的处理器进行编译。
  compile ‘com.google.auto.service:auto-service:1.0-rc2’

然后在processor中使用注解：
```
@AutoService(Processor.class)
public class RouterProcessor extends AbstractProcessor {
…
}
```

以上说明了怎么实现一个自定义的注解处理器，但是注解处理器根本没有做什么事情。编译时注解一般是要生成java的class文件，那么怎么生成呢？我们可以借助javapoet来实现。javapoet是一个生成java源文件的框架。后面来讲一下生成规则。
所以，一般情形，增加一个自定义注解处理器，离不开3个概念：

- procesor：注解处理类，另外AutoService和javapoet来完成源代码的生成
- AutoService ：作用是注解 processor 类，并对其生成 META-INF 的配置信息.
- javapoet：用于生成java.class文件



### 反射获取注解
```
//用spring容器获取Extension注解的bean对象
Map<String, Object> extensionBeans = this.applicationContext.getBeansWithAnnotation(Extension.class);
    extensionBeans.entrySet().stream().forEach((ey) -> {
      Class<?> extClazz = ey.getValue().getClass();
      //判断是否为代理对象
      if (AopUtils.isAopProxy(ey.getValue())) {
        //获取用户定义的类
        extClazz = ClassUtils.getUserClass(ey.getValue());
      }
      //获取注解的Extension对象
      Extension extensionPlus = (Extension)AnnotationUtils.findAnnotation(extClazz, Extension.class);
      Object pre = this.extBeans.put(extensionPlus.bizId(), ey.getValue());
      if (Objects.nonNull(pre)) {
        throw new RuntimeException("bizId has exist!!");
      }
    });

```

### 注解处理工具类
- AnnotationUtils开源工具类
```
getAnnotation: 从某个类获取某个annotation
findAnnotation: 从类或方法中查找某个annotation。
isAnnotationDeclaredLocally: 验证annotation是否直接注释在类上而不是集成来的。
isAnnotationInherited: 验证annotation是否继承于另一个class。
getAnnotationAttributes: 获取annotation的所有属性。
getValue: 获取指定annotation的值.
getDefaultValue: 获取指定annotation或annotation 属性的默认值
```

