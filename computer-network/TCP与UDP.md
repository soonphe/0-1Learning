# 0-1Learning

![alt text](../../static/common/svg/luoxiaosheng.svg "公众号")
![alt text](../../static/common/svg/luoxiaosheng_learning.svg "学习")
![alt text](../../static/common/svg/luoxiaosheng_wechat.svg "微信")

#TCP与UDP

### TCP协议(Transmission Control Protocol传输控制协议)
**TCP协议报文格式**
- 16位源端口号/16位目的端口号：表示数据从哪个进程来，要到那个进程去
- 32位序号：序号是可靠传输的关键因素。TCP将要传输的每个字节都进行了编号，序号是本报文段发送的数据组的第一个字节的编号，序号可以保证传输信息的有效性。比如：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为401。
- 32位确认序号：每一个ACK对应这一个确认号，它指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
- 4位首部长度(数据偏移)：**TCP报文默认大小为20个字节。** 表示该TCP头部有多少个32位bit(有多少个4字节)，所以TCP头部大长度是15 * 4 = 60。根据该部分可以将TCP报头和有效载荷分离。
- 6位标志位：
    - URG：它为了标志紧急指针是否有效。
    - ACK：标识确认号是否有效。
    - PSH：提示接收端应用程序立即将接收缓冲区的数据拿走。
    - RST：它是为了处理异常连接的， 告诉连接不一致的一方，我们的连接还没有建立好，要求对方重新建立连接。我们把携带RST标识的称为复位报文段。
    - SYN：请求建立连接; 我们把携带SYN标识的称为同步报文段。
    - FIN：通知对方, 本端要关闭连接了, 我们称携带FIN标识的为结束报文段。
- 16位窗口大小：如果发送方发送大量数据，接收方接收不过来，会导致大量数据丢失。然后接收方可以发送给发送发消息让发送方发慢一点，这是流量控制。接收方将自己接收缓冲器剩余空间的大小告诉发送方叫做16位窗口大小。发送发可以根据窗口大小来适配发送的速度和大小，窗口大小最大是2的16次方，及64KB，但也可以根据选项中的某些位置扩展，最大扩展1G。
- 16位校验和：发送端填充，CRC校验。如果接收端校验不通过， 则认为数据有问题(此处的检验和不光包含TCP首部也包含TCP数据部分)。
- 16位的紧急指针：按序到达是TCP协议保证可靠性的一种机制，但是也存在一些报文想优先被处理，这时就可以设置紧急指针，指向该报文即可，同时将紧急指针有效位置位1。
- 选项：选项大小=首部长度确定的报头长度-20个固定字节。（15）
- 数据

**TCP协议的特点:**
- 有连接：通信需要建立链接。需要三次握手建立连接，需要四次挥手断开连接
- 面向字节流：发送接收端可将报文分多次发送，可以一次读写若干字节，也可以一次全读写完；虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。
- 可靠传输：有确认应答，超时重传，流量控制，拥塞控制等机制保证TCP报文可靠性传输。

### TCP协议优缺点
* 优点：
 - 可靠，稳定
	    1、传递数据前，会有三次握手建立连接
        2、传递数据时，有确认、窗口、重传、拥塞控制
        3、传递数据后，会断开连接节省系统资源

* 缺点：
 - 传输慢，效率低，占用系统资源高：1、传递数据前，建立连接需要耗时; 2、传递数据时，确认、重传、拥塞等会消耗大量时间以及CPU和内存等硬件资源
 - 易被攻击：1、因为有确认机制，三次握手等机制，容易被人利用，实现DOS 、DDOS攻击

### TCP握手与挥手

#### 三次握手过程
1. 客户端发送：SYN = 1, SEQ = X, 端口号
2. 服务器回复：SYN = 1, ACK = X + 1, SEQ = Y
3. 客户端发送：ACK = Y + 1, SEQ = X + 1

> 确认应答信号ACK = 收到的SEQ + 1。
连接建立中，同步信号SYN始终为1。连接建立后，同步信号SYN=0。

#### 四次挥手过程
1. 客户端向服务端提出停止连接请求，FIN = M
2. 服务端收到，ACK = M + 1
3. 服务端向客户端提出停止连接请求，FIN = N
4. 客户端收到，ACK = N + 1

**为什么关闭连接会有四次比建立多一次**

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。

服务器收到客户端的 FIN 报文时，先回一个 ACK应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。

**TCP 挥手可以只需要三次吗？**

可以的。 三次挥手的前提是server端不会再发送数据了；因为服务器端收到客户端的FIN后，服务器端同时也要关闭连接，这样就可以把ACK和FIN合并到一起发送，节省了一个包，变成了“三次挥手”。

**tcp timewait 作用**

当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态，TIME_WAIT是TCP连接断开时必定会出现的状态

#### https握手过程
1. 客户端发起HTTPS请求，如浏览器发送自己支持的一套加密规则给网站
2. 网站选出一组加密算法和Hash算法，并将自己的身份信息用CA证书的形式发给浏览器, 证书里包含了网站地址，加密公钥，以及证书的颁发机构、过期时间等信息。（关于服务端的配置，采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。）
3. 浏览器获得网站证书之后浏览器要做以下工作：
   1. 验证证书的合法性（这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。）
   2. 如果证书受信任，则浏览器栏里面会显示一个小锁头，或者用户接受了不受信任的证书，浏览器会生成一串随机数密码(握手消息/会话秘钥)，然后用证书对该随机值进行加密（用最开始约定好的HASH方式，把握手消息取HASH值，然后用用证书中提供的公钥加密”握手消息+握手消息HASH值”），最后发送给服务端
4. 服务端拿到客户端传来的密码，用自己的私钥来解密握手消息，然后取出随机数密码，再用随机数密码解密握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。然后服务端自己也生成一个随机密码加密一段握手消息(握手消息+握手消息的HASH值)给客户端
5. 客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后的所有通信数据将由之前浏览器和服务器生成的随机码生成的一个新的随机密码并利用对称加密算法进行加密

### TCP通信机制

#### 确认应答机制
接收端收到一条报文后，向发送端发送一条确认ACK，此ACK的作用就是告诉发送端：接收端已经成功的收到了消息，并且希望收到下一条报文的序列号是什么。这个确认号就是期望的下一个报文的序号。

如，主机A给主机B发送了1-1000的数据，ACK应答，携带了1001序列号。告诉主机A，我已经接受到了1-1000数据，下一次你从1001开始发送数据。

> TCP将每个字节的数据进行编号，即序列号。每一个ACK都带有对应的确认序列号，意思是告诉发送者，我已经收到了哪些数据；下一次你从哪里开始发。

**TCP如何保证接收的顺序性：**
* TCP协议使用SEQ和ACK机制保证了顺序性
* TCP的每个报文都是有序号的。确认应答信号ACK=收到的SEQ+1

#### 超时重传机制
假设主机A发送数据给主机B，主机B没有收到数据包，主机B自然就不会应答，如果主机A在一个特定时间间隔内没有收到主机B发来的确认应答，就会进行重发，这就是超时重传机制。

当然还存在另一种可能就是主机A未收到B发来的确认应答，也可能是因为ACK丢失了。因此主机B会收到很多重复数据，那么TCP协议需要能够识别出那些包是重复的包， 并且把重复的包丢弃掉，这时候我们可以利用前面提到的16位序列号， 就可以很容易做到去重的效果。

TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间。
- Linux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。
- 如果重发一次之后，仍然得不到应答，等待 2500ms 后再进行重传。如果仍然得不到应答，等待 4500ms 进行重传。依次类推，超时时间以指数形式递增。
- 累计到一定的重传次数，TCP认为网络或者对端主机出现异常，强制关闭连接。不会一直重传。

> 序列号去重、超时时间递增、不会一直重传。

#### 连接管理机制
在正常情况下, TCP要经过三次握手建立连接，四次挥手断开连接。

为啥握手是三次?两次行不行?四次行不行?

四次可以，但是效率低，没有必要。每次传输的数据都需要进行一系列的封装和分用, 因此传输两次肯定要比传输一次慢很多。
两次是绝对不行的,两次只能确定双方中一方的发送和接收能力正常,另一方就不清楚了,这是不满足可靠性。

#### 流量控制
接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。
因此TCP支持根据接收端的接收能力，来决定发送端的发送速度。这个机制就叫做流量控制（Flow Control)。

接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段，通过ACK端通知发送端；
- 窗口大小字段越大，说明网络的吞吐量越高；
- 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端；
- 发送端接受到这个窗口之后，就会减慢自己的发送速度；
- 如果接收端缓冲区满了，就会将窗口置为0；这时发送方不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端

#### 拥塞控制
有了TCP的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。然而，如果在通信刚开始时就发送大量数据，也可能会引发其他问题。

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。

TCP引入 慢启动 机制，先发少量的数据，探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据。

因此TCP根据网络的承载能力，来决定传输速度。这个机制就叫做拥塞控制

TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制，因为IP层不向端系统提供显示的网络拥塞反馈。
主要通过拥塞窗口（cwnd）。运行在发送方的TCP拥塞控制机制对拥塞窗口进行跟踪，这个拥塞窗口对一个TCP发送方能向网络中发送流量的速率进行了限制。

#### 滑动窗口
实际上 滑动窗口 就是 流量控制 和 拥塞控制 的具体控制方式。

确认应答策略对每一个发送的数据段都要给一个ACK确认应答，接收方收到ACK后再发送下一个数据段，但是这样做有一个比较大的缺点，就是性能较差，尤其是数据往返的时间较长的时候。既然一发一收的方式性能较低，那么我们考虑一次发送多条数据，就可以大大的提高性能，它是将多个段的等待时间重叠在一起。

- 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。
- 如发送前四个段的时候，不需要等待任何ACK直接发送即可。
- 当收到第一个ACK后滑动窗口向后移动，继续发送第五个段的数据，然后依次类推。
- 操作系统内核为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有哪些数据没有应答。只有确认应答过的数据，才能从缓冲区删掉，
- 窗口越大，则网络的吞吐率就越高。滑动窗口左边代表已经发送过并且确认，可以从发送缓冲区中删除了，滑动窗口里边代表发送出去但是没有确认，滑动窗口右边代表还没有发送的数据。

#### tcp 粘包拆包和解决思路
粘包、拆包发生原因
```
1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
```

粘包、拆包解决办法
```
解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：
1. 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2. 发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3. 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。
```

### UDP协议(User Data Protocol用户数据包协议)
**UDP协议报文格式：**
1. 16位源端口：表示自己的端口号
2. 16位目的端口：表示将要发送的目的端口号。
3. 16位UDP长度：**8字节报头**和UDP数据的总长度，用于确定报文长度。
4. 16位校验和：用于在接收端对比校验，确定接收的UDP报文是否有错，如果校验和出错，就会直接丢弃(UDP校验首部和数据部分)。
5. UDP数据信息：数据

|   |   |
|---|---|
| 16位源端口  | 16位目的端口  |
| 16位UDP长度 | 16位UDP校验和 |
| 数据                    |


**UDP协议的特点:**
 - 无连接：传输数据之前源端和终端不建立连接，只知道对端的IP和端口号就可以发送，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快的把它扔到网络上
 - 速度快：吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制
 - 一对多：由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息
 - 不可靠：UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表；如果因为网络故障该段无法发到对方， UDP协议层也不会给应用层返回任何错误信息。。
 - 有边界：在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段
 - 开销小：**UDP标题默认8个字节**，相对于TCP的20个字节信息包的额外开销很小
 - 面向数据报：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。若报文太长，则IP层需要分片，降低效率，为减少UDP丢包风险，我们最好能控制UDP包在下层协议的传输过程中不要被切割。若太短，有可能会被丢弃；
 
**UDP报文选择**
- UDP是不可靠的传输协议，为了减少UDP包丢失的风险，我们最好能控制UDP包在下层协议的传输过程中不要被切割。
- MTU最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII帧的结构DMAC+SMAC+Type+Data+CRC由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64字节，最大不能超过1518字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧
- 由于以太网EthernetII最大的数据帧是1518字节，除去以太网帧的帧头（DMAC目的MAC地址48bit=6Bytes+SMAC源MAC地址48bit=6Bytes+Type域2bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500字节这个值我们就把它称之为MTU。
- 要想IP层不分包，UDP数据包的最大大小应该是1500字节 – IP头(20字节) – UDP头(8字节) = 1472字节。不过鉴于Internet上的标准MTU值为576字节，所以建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在 (576-8-20)548字节以内。

> “ping”命令：其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

### UDP协议优缺点
* 优点：
 - 传输速率快：1、传输数据前，不需要像TCP一样建立连接 ；2、传输数据时，没有确认、窗口、重传、拥塞控制等机制
 - 较安全：由于没有了TCP的一些机制，被攻击者利用的漏洞就少了
* 缺点：
 - 不可靠，不稳定
 1、由于没有了TCP的机制，在数据传输时如果网络不好，很可能丢包

**用UDP协议通讯时怎样得知目标机是否获得了数据包**
* 仿造TCP的做法，每发一个UDP包，都在里面加一个SEQ序号，接收方收到包后，将SEQ序号回复给发送方。如果发送方在指定时间以内没有收到回应，说明丢包了。

### TCP与UDP的区别
- TCP面向有链接的通信服务，TCP提供可靠的通信传输，TCP一对一，TCP保证数据顺序，TCP数据无边界，TCP面向字节流，TCP报头至少20字节，TCP有流量控制，拥塞控制
- UDP面向无连接的通信服务，UDP不可靠,会丢包，UDP可以一对一，一对多，UDP不保证顺序，UDP有边界，UDP面向报文，UDP报头8字节，UDP没有

**为什么UDP比TCP快**
1. TCP需要三次握手
2. TCP有拥塞控制，控制流量等机制
 
**为什么TCP比UDP可靠**
1. TCP是面向有连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。
2. TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有。因此可能丢包。

**为什么TCP无边界，UDP有边界**
- TCP无边界：客户端分多次发送数据给服务器，若服务器的缓冲区够大，那么服务器端会在客户端发送完之后一次性接收过来，所以是无边界的；
- UDP有边界：客户端每发送一次，服务器端就会接收一次，也就是说发送多少次就会接收多少次，因此是有边界的。

### TCP和UDP使用场景
**什么时候应该使用TCP**

当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。

在日常生活中，常见使用TCP协议的应用如下：
- 浏览器，用的HTTP
- FlashFXP，用的FTP
- Outlook，用的POP、SMTP
- Putty，用的Telnet、SSH

**什么时候应该使用UDP**

当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： 、语音、视频、TFTP等

### TCP连接数
TCP 端口数量，上限是 6.5w（65535，16 bit）

如何标识一个TCP连接
在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{localip, localport,remoteip,remoteport} = {本地ip，本地port，远程ip，远程port}

client最大tcp连接数
client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，一个client最大tcp连接数为65535，这些连接可以连到不同的serverip。

server最大tcp连接数
server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remoteip（也就是clientip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。

实际的tcp连接数
上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。

所以，对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万,甚至上百万是没问题的。
这明显是进入了思维的误区，65535是指可用的端口总数，并不代表服务器同时只能接受65535个并发连接。



